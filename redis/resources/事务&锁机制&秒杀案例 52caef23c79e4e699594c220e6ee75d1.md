# 事务&锁机制&秒杀案例

# 一、事务

## 1. 定义

- Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断

## 2. **Multi、Exec、discard**

![Untitled](%E4%BA%8B%E5%8A%A1&%E9%94%81%E6%9C%BA%E5%88%B6&%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B%2052caef23c79e4e699594c220e6ee75d1/Untitled.png)

- 从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行
- 组队的过程中可以通过discard来放弃组队
- 案例演示
    
    ```bash
    redis 127.0.0.1:6379> MULTI
    OK
    
    redis 127.0.0.1:6379> SET book-name "Mastering C++ in 21 days"
    QUEUED
    
    redis 127.0.0.1:6379> GET book-name
    QUEUED
    
    redis 127.0.0.1:6379> EXEC
    1) OK
    2) "Mastering C++ in 21 days"
    ```
    

## 3. **事务的错误处理**

- 组队阶段中某个命令出现了报告错误，执行时整个的所有队列都会被取消
- 执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚

## 4. 事物三大特性

- 单独的隔离操作
    - 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
- 没有隔离级别的概念
    - 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行
- 不保证原子性
    - 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚

# 2. 锁机制

## 2.1 事物冲突问题

- 想想一个场景：有很多人有你的账户,同时去参加双十一抢购
- 一个请求想给金额减8000；一个请求想给金额减5000；一个请求想给金额减1000
    
    ![Untitled](%E4%BA%8B%E5%8A%A1&%E9%94%81%E6%9C%BA%E5%88%B6&%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B%2052caef23c79e4e699594c220e6ee75d1/Untitled%201.png)
    

<aside>
💡 可以通过redis的锁机制解决事物冲突问题

</aside>

## 2.2 悲观锁

![Untitled](%E4%BA%8B%E5%8A%A1&%E9%94%81%E6%9C%BA%E5%88%B6&%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B%2052caef23c79e4e699594c220e6ee75d1/Untitled%202.png)

- **悲观锁(Pessimistic Lock)**, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁

<aside>
➡️ **传统的关系型数据库里边就用到了很多这种锁机制**，比如**行锁**，**表锁，读锁**，**写锁**等，都是在做操作之前先上锁

</aside>

## 2.3 乐观锁

![Untitled](%E4%BA%8B%E5%8A%A1&%E9%94%81%E6%9C%BA%E5%88%B6&%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B%2052caef23c79e4e699594c220e6ee75d1/Untitled%203.png)

- **乐观锁(Optimistic Lock),** 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据
- 例如使用版本号的check-and-set机制（redis就使用了这种机制）

<aside>
💡 乐观锁适用于多读的应用类型，这样可以提高吞吐量

</aside>

## 2.4 WATCH & UNWATCH

- 在执行multi之前，先执行`watch key1 [key2]`,可以监视一个(或多个) key ，如果在事务**执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断**
- `UNWATCH`取消 WATCH 命令对所有 key 的监视
- 如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了

# 3. 秒杀案例

## 3.1 案例场景

![Untitled](%E4%BA%8B%E5%8A%A1&%E9%94%81%E6%9C%BA%E5%88%B6&%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B%2052caef23c79e4e699594c220e6ee75d1/Untitled%204.png)

- 该案例的java代码参照资料中SecKill源码

## 3.2 并发访问测试

- 安装工具： **`yum install httpd-tools`**
- ab测试
    
    ```bash
    #模拟表单提交参数,以&符号结尾;存放在当前目录
    vim postfile  #内容：prodid=0101&
    #ab测试
    ab -n 1000 -c 100 -k -p ~/postfile -T application/x-www-form-urlencoded http://192.168.2.115:8081/Seckill/doseckill
    # 1000此请求，100此并发
    # 请求参数引用当前目录下postfile文件
    ```
    

## 3.3 案例中存在的问题

- 连接超时
    - 通过连接池来解决，与Mysql中的连接池类似
- 超卖问题
    
    ![Untitled](%E4%BA%8B%E5%8A%A1&%E9%94%81%E6%9C%BA%E5%88%B6&%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B%2052caef23c79e4e699594c220e6ee75d1/Untitled%205.png)
    
    - 当前库存为1，由于执行了两次库存减一的操作，最后库存变为-1
- 解决超卖问题
    - 添加乐观锁
        
        ![Untitled](%E4%BA%8B%E5%8A%A1&%E9%94%81%E6%9C%BA%E5%88%B6&%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B%2052caef23c79e4e699594c220e6ee75d1/Untitled%206.png)
        
    - 乐观锁可能会导致库存遗留问题，即已经有足够的秒杀请求，最后却依然有库存剩余
        - 原因：乐观锁导致很多请求都失败
- 解决库存遗留问题
    - 使用Lua脚本
        - LUA脚本类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作
        - 通过lua脚本解决**争抢问题**，实际上是**redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题**
    
    <aside>
    💡 redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用
    
    </aside>